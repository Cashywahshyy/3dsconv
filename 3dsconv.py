#!/usr/bin/env python2

# 3dsconv.py by ihaveamac
# license: MIT License
# https://github.com/ihaveamac/3dsconv

import binascii
import errno
import glob
import hashlib
import itertools
import math
import os
import struct
import sys
import zlib

# default directories (relative to current dir unless you use absolute paths)
# leave as "" for current working directory
# using --xorpads= or --output= will override these
xorpad_directory = ""
output_directory = ""

workdir = "work"  # temporary folder to store files in

#################
version = "3.0"

helptext = """3dsconv.py ~ version %s
"convert" a Nintendo 3DS ROM to a CIA (CTR Importable Archive)
https://github.com/ihaveamac/3dsconv

usage: 3dsconv.py [options] game.3ds [game.3ds ...]
  --xorpads=<dir>  - use XORpads in the specified directory
                     default is %s
  --output=<dir>   - save converted CIA files in the specified directory
                     default is %s
  --overwrite      - overwrite any existing converted CIA, if it exists
  --gen-ncchinfo   - generate ncchinfo.bin for ROMs that don't have a valid xorpad
  --gen-ncch-all   - use with --gen-ncchinfo to generate an ncchinfo.bin for all ROMs
  --noconvert      - don't convert ROMs, useful if you just want to generate ncchinfo.bin
  --nocleanup      - don't remove temporary files once finished
  --verbose        - print more information

- encrypted roms require an ExHeader XORpad with the name format:
    \"<TITLEID>.Main.exheader.xorpad\"
  XORpads should be in %s or the directory specified by --xorpads=<dir>
  XORpads are generated by using ncchinfo.bin with Decrypt9 on a 3DS system
- encrypted and decrypted roms can be converted at the same time"""

# includes certificate chain, ticket (blank titlekey and title id), and tmd signature + blank header (blank title id)
#    + blank content info records
# compressed using zlib then encoded with base64
ciainfo = """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
YtNfNM8GG2ywwQYbbLDB/xS/AbtxR+8="""

if len(sys.argv) < 2:
    print(helptext % (version, ("current directory" if xorpad_directory == "" else "'%s'" % xorpad_directory),
                      ("current directory" if output_directory == "" else "'%s'" % output_directory),
                      ("the current directory" if xorpad_directory == "" else "'%s'" % xorpad_directory)))
    sys.exit(1)

mu = 0x200  # media unit
readsize = 8 * 1024 * 1024  # used from padxorer

cleanup = "--nocleanup" not in sys.argv
verbose = "--verbose" in sys.argv
overwrite = "--overwrite" in sys.argv
genncchinfo = "--gen-ncchinfo" in sys.argv
genncchall = "--gen-ncch-all" in sys.argv
noconvert = "--noconvert" in sys.argv


def print_v(msg):
    if verbose:
        print(msg)


# used from http://stackoverflow.com/questions/10840533/most-pythonic-way-to-delete-a-file-which-may-not-exist
def silentremove(filename):
    try:
        os.remove(filename)
    except OSError as e:  # this would be "except OSError, e:" before Python 2.6
        if e.errno != errno.ENOENT:  # errno.ENOENT = no such file or directory
            raise  # re-raise exception if a different error occured


def docleanup(tid_dc):
    silentremove("work/%s-game-orig.cxi" % tid_dc)
    silentremove("work/%s-game-conv.cxi" % tid_dc)
    silentremove("work/%s-manual.cfa" % tid_dc)
    silentremove("work/%s-dlpchild.cfa" % tid_dc)


# based on http://stackoverflow.com/questions/1766535/bit-hack-round-off-to-multiple-of-8/1766566#1766566
def roundup(x):
    return ((int(x, 16) + 63) >> 6) << 6


ncchinfolist = []
ncchinfo_used_roms = []


# see this for ncchinfo.bin format:
# https://github.com/d0k3/Decrypt9WIP/blob/master/scripts/ncchinfo_gen.py
# this only does ExHeader stuff
# so I think I can get away with hard-coding some things
def ncchinfoadd(rom_ncchinfo):
    if rom_ncchinfo not in ncchinfolist:
        print_v("- adding %s to ncchinfo.bin" % rom_ncchinfo)
        with open(rom_ncchinfo, "rb") as romf_ncchinfo:
            romf_ncchinfo.seek(0x108)
            tid_ncchinfo = romf_ncchinfo.read(8)
            romf_ncchinfo.seek(0x120)
            romf_ncchinfo.seek(bytes2int(romf_ncchinfo.read(0x4)[::-1]) * mu)  # first partition offset
            keyy_ncchinfo = romf_ncchinfo.read(16)
            ncchinfolist.append(tid_ncchinfo[::-1] + "\x01\x00\x00\x00\x00\x00\x00\x00" + keyy_ncchinfo +
                                "\x01\x00\x00\x00" + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" +
                                tid_ncchinfo + ("/%s.Main.exheader.xorpad" % binascii.hexlify(tid_ncchinfo[::-1])
                                                .upper()).ljust(112, "\x00"))
        ncchinfo_used_roms.append(rom_ncchinfo)


# used from http://www.gossamer-threads.com/lists/python/python/163938
def bytes2int(string):
    i_s = 0
    for ch in string:
        i_s = 256 * i_s + ord(ch)
    return i_s

totalroms = 0
processedroms = 0

# probably should've used argparse
files = []
for arg in sys.argv[1:]:
    if arg[:2] != "--":
        toadd = glob.glob(arg)
        if len(toadd) == 0:
            print("! %s doesn't exist." % arg)
            totalroms += 1
        else:
            for inputf in toadd:
                romname = os.path.basename(os.path.splitext(inputf)[0])
                cianame = os.path.join(output_directory, romname + ".cia")
                if not overwrite and os.path.isfile(cianame):
                    print("! %s already exists." % cianame)
                    print("  to force conversion and overwriting this, use --overwrite")
                    continue
                files.append([inputf, romname, cianame])
    elif arg[:10] == "--xorpads=":
        xorpad_directory = arg[10:]
    elif arg[:9] == "--output=":
        output_directory = arg[9:]

if output_directory != "":
    try:
        os.makedirs(output_directory)
    except OSError:
        if not os.path.isdir(output_directory):
            raise

if not files:
    print("! no inputted files exist.")
    sys.exit(1)

for rom in files:
    if genncchinfo and genncchall:
        ncchinfoadd(rom[0])
    totalroms += 1
    with open(rom[0], "rb") as romf:
        romf.seek(0x100)
        ncsdmagic = romf.read(4)
        if ncsdmagic != "NCSD":
            print("! %s is probably not a Nintendo 3DS ROM." % rom[0])
            print_v("  NCSD magic not found (offset 0x100)")
            romf.close()
            continue
        romf.seek(0x108)
        tid_bin = romf.read(8)[::-1]
        tid = binascii.hexlify(tid_bin)
        xorpad = os.path.join(xorpad_directory, "%s.Main.exheader.xorpad" % tid.upper())

        # find Game Executable CXI
        romf.seek(0x120)
        gamecxi_offset = bytes2int(romf.read(0x4)[::-1]) * mu
        gamecxi_size = bytes2int(romf.read(0x4)[::-1]) * mu
        # find Manual CFA
        romf.seek(0x128)
        manualcfa_offset = bytes2int(romf.read(0x4)[::-1]) * mu
        manualcfa_size = bytes2int(romf.read(0x4)[::-1]) * mu
        # find Download Play child container CFA
        romf.seek(0x130)
        dlpchildcfa_offset = bytes2int(romf.read(0x4)[::-1]) * mu
        dlpchildcfa_size = bytes2int(romf.read(0x4)[::-1]) * mu

        # probably should calculate these but I'm lazy this is easier
        tmdpadding = "\x00" * 12  # padding to add at the end of the tmd
        contentcount = "\x01"  # for convenience later since this has to be written a few times
        tmdsize = "\x34\x0B\x00\x00\x00\x00\x00\x00"  # for convenience when writing the CIA header
        contentindex = "\x80"  # some weird thing in the CIA header
        if manualcfa_offset != 0:
            tmdpadding = "\x00" * 28
            contentcount = "\x02"
            tmdsize = "\x64\x0B\x00\x00\x00\x00\x00\x00"
            contentindex = "\xC0"
        if dlpchildcfa_offset != 0:
            tmdpadding = "\x00" * 44
            contentcount = "\x03"
            tmdsize = "\x94\x0B\x00\x00\x00\x00\x00\x00"
            contentindex = "\xE0"

        romf.seek(gamecxi_offset + 0x18F)
        decrypted = int(binascii.hexlify(romf.read(1))) & 0x04
        print("- processing: %s (%s)" % (rom[1], "decrypted" if decrypted else "encrypted"))
        if noconvert:
            print("- not converting %s (%s) because --noconvert was used" %
                  (rom[1], "decrypted" if decrypted else "encrypted"))
            if cleanup:
                docleanup(tid)
            romf.close()
            if genncchinfo:
                ncchinfoadd(rom[0])
            continue
        if not decrypted:
            if not os.path.isfile(xorpad):
                print("! %s couldn't be found." % xorpad)
                if not genncchinfo:
                    print("  use --gen-ncchinfo with this ROM.")
                else:
                    ncchinfoadd(rom[0])
                romf.close()
                continue

        docleanup(tid)

        # Game Executable first-half ExHeader
        print_v("- verifying ExHeader")
        romf.seek(0x4200)
        exh = romf.read(0x400)
        xor = ""
        if not decrypted:
            print_v("- decrypting ExHeader")
            with open(xorpad, "rb") as xorfile:
                xor = xorfile.read(0x400)
            xored = ""
            for byte_f, byte_x in zip(exh, xor):
                xored += chr(ord(byte_f) ^ ord(byte_x))
            exh = xored
        exh_hash = hashlib.sha256(exh).digest()
        romf.seek(0x4160)
        ncch_exh_hash = romf.read(0x20)
        if exh_hash != ncch_exh_hash:
            if decrypted:
                print("! this ROM might be corrupt.")
            else:
                print("! %s is not the correct XORpad, or is corrupt." % xorpad)
                if not genncchinfo:
                    print("  try using --gen-ncchinfo again or find the correct XORpad.")
                else:
                    ncchinfoadd(rom[0])
            print_v("  ExHeader SHA-256 hash check failed.")
            romf.close()
            if cleanup:
                docleanup(tid)
            continue

        print_v("- patching ExHeader")
        exh_list = list(exh)
        x = ord(exh_list[0xD])
        z = x | 2
        print_v("  offset 0xD of ExHeader:")
        print_v("  original: %s" % hex(x))
        print_v("  shifted:  %s" % hex(z))
        z = chr(z)
        exh_list[0xD:0xE] = z
        # there really has to be a better way to do this...
        # savesize = str(int(binascii.hexlify(exh[0x1C0:0x1C8][::-1]), 16) / 1024)
        exh = "".join(exh_list)
        savesize = exh[0x1C0:0x1C8]
        new_exh_hash = hashlib.sha256("".join(exh)).digest()

        if not decrypted:
            print_v("- re-encrypting ExHeader")
            xored = ""
            for byte_f, byte_x in zip(exh_list, xor):
                xored += chr(ord(byte_f) ^ ord(byte_x))
            exh = xored

        # Game Executable NCCH Header
        print_v("- reading NCCH header of Game Executable CXI")
        romf.seek(gamecxi_offset)
        ncch_header = list(romf.read(0x200))
        ncch_header[0x160:0x180] = list(new_exh_hash)
        ncch_header = "".join(ncch_header)

        # CIA
        with open(rom[2], "wb") as cia:
            print_v("- writing CIA header")
            chunkrecords  = "\x00" * 0xC  # 1st content: ID 0x00000000, Index 0x0000
            chunkrecords += struct.pack(">I", gamecxi_size)
            chunkrecords += "\x00" * 0x20  # sha256 hash to be filled in later
            if manualcfa_offset != 0:
                chunkrecords += binascii.unhexlify("000000010001000000000000")  # 2nd content: ID 0x00000001, Index 0x0001
                chunkrecords += struct.pack(">I", manualcfa_size)
                chunkrecords += "\x00" * 0x20  # sha256 hash to be filled in later
            if dlpchildcfa_offset != 0:
                chunkrecords += binascii.unhexlify("000000020002000000000000")  # 3nd content: ID 0x00000002, Index 0x0002
                chunkrecords += struct.pack(">I", dlpchildcfa_size)
                chunkrecords += "\x00" * 0x20  # sha256 hash to be filled in later

            cia.write(binascii.unhexlify("2020000000000000000A000050030000") + tmdsize
                      + struct.pack("<I", gamecxi_size + manualcfa_size + dlpchildcfa_size)
                      + ("\x00" * 4) + contentindex + ("\x00" * 0x201F)
                      + zlib.decompress(ciainfo.decode('base64'))
                      + chunkrecords + tmdpadding)

            chunkrecords = list(chunkrecords)  # to update hashes in it, then calculate the hash over the entire thing

            cia.seek(0x2F9F)
            cia.write(contentcount)

            cia.seek(0x2C1C)
            cia.write(tid_bin)
            cia.seek(0x2F4C)
            cia.write(tid_bin)

            cia.seek(0x2F5A)
            cia.write(savesize)

            # Game Executable CXI NCCH Header + first-half ExHeader
            cia.seek(0, 2)
            gamecxi_hash = hashlib.sha256(ncch_header + exh)
            cia.write(ncch_header + exh)

            # Game Executable CXI second-half ExHeader + contents
            print_v("- writing Game Executable CXI")
            print_v("  offset: %s" % hex(gamecxi_offset))
            print_v("  size:   %s" % hex(gamecxi_size))
            romf.seek(gamecxi_offset + 0x200 + 0x400)
            left = gamecxi_size - 0x200 - 0x400
            tmpread = ""
            for __ in itertools.repeat(0, int(math.floor((gamecxi_size / readsize)) + 1)):
                toread = min(readsize, left)
                tmpread = romf.read(toread)
                gamecxi_hash.update(tmpread)
                cia.write(tmpread)
                left -= readsize
                if left <= 0:
                    break
            print_v("- Game Executable CXI SHA-256 hash:")
            print_v("  " + gamecxi_hash.hexdigest())
            cia.seek(0x38D4)
            cia.write(gamecxi_hash.digest())
            chunkrecords[0x10:0x30] = list(gamecxi_hash.digest())

            # Manual CFA
            if manualcfa_offset != 0:
                cia.seek(0, 2)
                print_v("- writing Manual CFA")
                manualcfa_hash = hashlib.sha256()
                print_v("  offset: %s" % hex(manualcfa_offset))
                print_v("  size:   %s" % hex(manualcfa_size))
                romf.seek(manualcfa_offset)
                left = manualcfa_size
                for __ in itertools.repeat(0, int(math.floor((manualcfa_size / readsize)) + 1)):
                    toread = min(readsize, left)
                    tmpread = romf.read(toread)
                    manualcfa_hash.update(tmpread)
                    cia.write(tmpread)
                    left -= readsize
                    if left <= 0:
                        break
                print_v("- Manual CFA SHA-256 hash:")
                print_v("  " + manualcfa_hash.hexdigest())
                cia.seek(0x3904)
                cia.write(manualcfa_hash.digest())
                chunkrecords[0x40:0x60] = list(manualcfa_hash.digest())


            # Download Play child container CFA
            if dlpchildcfa_offset != 0:
                cia.seek(0, 2)
                print_v("- writing Download Play child container CFA")
                dlpchildcfa_hash = hashlib.sha256()
                print_v("  offset: %s" % hex(dlpchildcfa_offset))
                print_v("  size:   %s" % hex(dlpchildcfa_size))
                romf.seek(dlpchildcfa_offset)
                left = dlpchildcfa_size
                for __ in itertools.repeat(0, int(math.floor((dlpchildcfa_size / readsize)) + 1)):
                    toread = min(readsize, left)
                    tmpread = romf.read(toread)
                    dlpchildcfa_hash.update(tmpread)
                    cia.write(tmpread)
                    left -= readsize
                    if left <= 0:
                        break
                print_v("- Download Play child container CFA SHA-256 hash:")
                print_v("  " + dlpchildcfa_hash.hexdigest())
                cia.seek(0x3934)
                cia.write(dlpchildcfa_hash.digest())
                chunkrecords[0x70:0x90] = list(dlpchildcfa_hash.digest())

            print_v("- updating hashes")
            chunkrecords_hash = hashlib.sha256("".join(chunkrecords))
            print_v("- Content chunk records SHA-256 hash:")
            print_v("  " + chunkrecords_hash.hexdigest())

            cia.seek(0x2FC7)
            cia.write(contentcount + chunkrecords_hash.digest())

            cia.seek(0x2FA4)
            inforecords_hash = hashlib.sha256("\x00\x00\x00" + contentcount + chunkrecords_hash.digest()
                                              + ("\x00"*0x8DC))
            print_v("- Content info records SHA-256 hash:")
            print_v("  " + inforecords_hash.hexdigest())
            cia.write(inforecords_hash.digest())

    if cleanup:
        docleanup(tid)

    processedroms += 1

if totalroms == 0:
    print(helptext % (version, ("current directory" if xorpad_directory == "" else "'%s'" % xorpad_directory),
                      ("current directory" if output_directory == "" else "'%s'" % output_directory),
                      ("the current directory" if xorpad_directory == "" else "'%s'" % xorpad_directory)))
    sys.exit(1)
else:
    if genncchinfo and len(ncchinfolist) != 0:
        print("- saving ncchinfo.bin")
        with open("ncchinfo.bin", "wb") as ncchinfo:
            ncchinfo.write("\xFF\xFF\xFF\xFF\x04\x00\x00\xF0")
            # this is bad, I know
            ncchinfo.write(binascii.unhexlify(format(len(ncchinfolist), 'x').rjust(8, '0'))[::-1])
            ncchinfo.write("\x00\x00\x00\x00")
            for i in ncchinfolist:
                ncchinfo.write(i)
        print("- use Decrypt9 on a 3DS system to generate the XORpads.")
        print("  place the file at the root or in a folder called \"Decrypt9\".")
        print("  view the Decrypt9 README and download releases at")
        print("  https://github.com/d0k3/Decrypt9WIP")
    print("* done converting!")
    print("  %i out of %i roms processed" % (processedroms, totalroms))
