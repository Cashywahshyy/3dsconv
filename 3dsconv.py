#!/usr/bin/env python2

# 3dsconv.py by ihaveamac
# license: MIT License
# https://github.com/ihaveamac/3dsconv

import binascii
import errno
import glob
import hashlib
import itertools
import math
import os
import struct
import sys
import zlib

# default directories (relative to current dir unless you use absolute paths)
# leave as "" for current working directory
# using --xorpads= or --output= will override these
xorpad_directory = ""
output_directory = ""

workdir = "work"  # temporary folder to store files in

#################
version = "2.2"

helptext = """3dsconv.py ~ version %s
"convert" a Nintendo 3DS ROM to a CIA (CTR Importable Archive)
https://github.com/ihaveamac/3dsconv

usage: 3dsconv.py [options] game.3ds [game.3ds ...]
  --xorpads=<dir>  - use XORpads in the specified directory
                     default is %s
  --output=<dir>   - save converted CIA files in the specified directory
                     default is %s
  --overwrite      - overwrite any existing converted CIA, if it exists
  --gen-ncchinfo   - generate ncchinfo.bin for ROMs that don't have a valid xorpad
  --gen-ncch-all   - use with --gen-ncchinfo to generate an ncchinfo.bin for all ROMs
  --noconvert      - don't convert ROMs, useful if you just want to generate ncchinfo.bin
  --nocleanup      - don't remove temporary files once finished
  --verbose        - print more information

- encrypted roms require an ExHeader XORpad with the name format:
    \"<TITLEID>.Main.exheader.xorpad\"
  XORpads should be in %s or the directory specified by --xorpads=<dir>
  XORpads are generated by using ncchinfo.bin with Decrypt9 on a 3DS system
- encrypted and decrypted roms can be converted at the same time"""

# includes certificate chain, ticket (blank titlekey and title id), and tmd signature + blank header (blank title id)
#    + blank content info records
# compressed using zlib then encoded with base64
ciainfo = """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"""

if len(sys.argv) < 2:
    print(helptext % (version, ("current directory" if xorpad_directory == "" else "'%s'" % xorpad_directory),
                      ("current directory" if output_directory == "" else "'%s'" % output_directory),
                      ("the current directory" if xorpad_directory == "" else "'%s'" % xorpad_directory)))
    sys.exit(1)

mu = 0x200  # media unit
readsize = 8 * 1024 * 1024  # used from padxorer

cleanup = "--nocleanup" not in sys.argv
verbose = "--verbose" in sys.argv
overwrite = "--overwrite" in sys.argv
genncchinfo = "--gen-ncchinfo" in sys.argv
genncchall = "--gen-ncch-all" in sys.argv
noconvert = "--noconvert" in sys.argv


def print_v(msg):
    if verbose:
        print(msg)


# used from http://stackoverflow.com/questions/10840533/most-pythonic-way-to-delete-a-file-which-may-not-exist
def silentremove(filename):
    try:
        os.remove(filename)
    except OSError as e:  # this would be "except OSError, e:" before Python 2.6
        if e.errno != errno.ENOENT:  # errno.ENOENT = no such file or directory
            raise  # re-raise exception if a different error occured


def docleanup(tid_dc):
    silentremove("work/%s-game-orig.cxi" % tid_dc)
    silentremove("work/%s-game-conv.cxi" % tid_dc)
    silentremove("work/%s-manual.cfa" % tid_dc)
    silentremove("work/%s-dlpchild.cfa" % tid_dc)


# based on http://stackoverflow.com/questions/1766535/bit-hack-round-off-to-multiple-of-8/1766566#1766566
def roundup(x):
    return ((int(x, 16) + 63) >> 6) << 6


ncchinfolist = []
ncchinfo_used_roms = []


# see this for ncchinfo.bin format:
# https://github.com/d0k3/Decrypt9WIP/blob/master/scripts/ncchinfo_gen.py
# this only does ExHeader stuff
# so I think I can get away with hard-coding some things
def ncchinfoadd(rom_ncchinfo):
    if rom_ncchinfo not in ncchinfolist:
        print_v("- adding %s to ncchinfo.bin" % rom_ncchinfo)
        with open(rom_ncchinfo, "rb") as romf_ncchinfo:
            romf_ncchinfo.seek(0x108)
            tid_ncchinfo = romf_ncchinfo.read(8)
            romf_ncchinfo.seek(0x120)
            romf_ncchinfo.seek(bytes2int(romf_ncchinfo.read(0x4)[::-1]) * mu)  # first partition offset
            keyy_ncchinfo = romf_ncchinfo.read(16)
            ncchinfolist.append(tid_ncchinfo[::-1] + "\x01\x00\x00\x00\x00\x00\x00\x00" + keyy_ncchinfo +
                                "\x01\x00\x00\x00" + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" +
                                tid_ncchinfo + ("/%s.Main.exheader.xorpad" % binascii.hexlify(tid_ncchinfo[::-1])
                                                .upper()).ljust(112, "\x00"))
        ncchinfo_used_roms.append(rom_ncchinfo)


# used from http://www.gossamer-threads.com/lists/python/python/163938
def bytes2int(string):
    i_s = 0
    for ch in string:
        i_s = 256 * i_s + ord(ch)
    return i_s

totalroms = 0
processedroms = 0

# probably should've used argparse
files = []
for arg in sys.argv[1:]:
    if arg[:2] != "--":
        toadd = glob.glob(arg)
        if len(toadd) == 0:
            print("! %s doesn't exist." % arg)
            totalroms += 1
        else:
            for inputf in toadd:
                romname = os.path.basename(os.path.splitext(inputf)[0])
                cianame = os.path.join(output_directory, romname + ".cia")
                if not overwrite and os.path.isfile(cianame):
                    print("! %s already exists." % cianame)
                    print("  to force conversion and overwriting this, use --overwrite")
                    continue
                files.append([inputf, romname, cianame])
    elif arg[:10] == "--xorpads=":
        xorpad_directory = arg[10:]
    elif arg[:9] == "--output=":
        output_directory = arg[9:]

if output_directory != "":
    try:
        os.makedirs(output_directory)
    except OSError:
        if not os.path.isdir(output_directory):
            raise

if not files:
    print("! no inputted files exist.")
    sys.exit(1)

for rom in files:
    if genncchinfo and genncchall:
        ncchinfoadd(rom[0])
    totalroms += 1
    with open(rom[0], "rb") as romf:
        romf.seek(0x100)
        ncsdmagic = romf.read(4)
        if ncsdmagic != "NCSD":
            print("! %s is probably not a Nintendo 3DS ROM." % rom[0])
            print_v("  NCSD magic not found (offset 0x100)")
            romf.close()
            continue
        romf.seek(0x108)
        tid_bin = romf.read(8)[::-1]
        tid = binascii.hexlify(tid_bin)
        xorpad = os.path.join(xorpad_directory, "%s.Main.exheader.xorpad" % tid.upper())

        # find Game Executable CXI
        romf.seek(0x120)
        gamecxi_offset = bytes2int(romf.read(0x4)[::-1]) * mu
        gamecxi_size = bytes2int(romf.read(0x4)[::-1]) * mu
        # find Manual CFA
        romf.seek(0x128)
        manualcfa_offset = bytes2int(romf.read(0x4)[::-1]) * mu
        manualcfa_size = bytes2int(romf.read(0x4)[::-1]) * mu
        # find Download Play child container CFA
        romf.seek(0x130)
        dlpchildcfa_offset = bytes2int(romf.read(0x4)[::-1]) * mu
        dlpchildcfa_size = bytes2int(romf.read(0x4)[::-1]) * mu

        # probably should calculate these but I'm lazy this is easier
        tmdpadding = "\x00" * 12  # padding to add at the end of the tmd
        contentcount = "\x01"  # for convenience later since this has to be written a few times
        tmdsize = "\x34\x0B\x00\x00\x00\x00\x00\x00"  # for convenience when writing the CIA header
        contentindex = "\x80"  # some weird thing in the CIA header
        if manualcfa_offset != 0:
            tmdpadding = "\x00" * 28
            contentcount = "\x02"
            tmdsize = "\x64\x0B\x00\x00\x00\x00\x00\x00"
            contentindex = "\xC0"
        if dlpchildcfa_offset != 0:
            tmdpadding = "\x00" * 44
            contentcount = "\x03"
            tmdsize = "\x94\x0B\x00\x00\x00\x00\x00\x00"
            contentindex = "\xE0"

        romf.seek(gamecxi_offset + 0x18F)
        decrypted = int(binascii.hexlify(romf.read(1))) & 0x04
        print("- processing: %s (%s)" % (rom[1], "decrypted" if decrypted else "encrypted"))
        if noconvert:
            print("- not converting %s (%s) because --noconvert was used" %
                  (rom[1], "decrypted" if decrypted else "encrypted"))
            if cleanup:
                docleanup(tid)
            romf.close()
            if genncchinfo:
                ncchinfoadd(rom[0])
            continue
        if not decrypted:
            if not os.path.isfile(xorpad):
                print("! %s couldn't be found." % xorpad)
                if not genncchinfo:
                    print("  use --gen-ncchinfo with this ROM.")
                else:
                    ncchinfoadd(rom[0])
                romf.close()
                continue

        docleanup(tid)

        # Game Executable first-half ExHeader
        print_v("- verifying ExHeader")
        romf.seek(0x4200)
        exh = romf.read(0x400)
        xor = ""
        if not decrypted:
            print_v("- decrypting ExHeader")
            with open(xorpad, "rb") as xorfile:
                xor = xorfile.read(0x400)
            xored = ""
            for byte_f, byte_x in zip(exh, xor):
                xored += chr(ord(byte_f) ^ ord(byte_x))
            exh = xored
        exh_hash = hashlib.sha256(exh).digest()
        romf.seek(0x4160)
        ncch_exh_hash = romf.read(0x20)
        if exh_hash != ncch_exh_hash:
            if decrypted:
                print("! this ROM might be corrupt.")
            else:
                print("! %s is not the correct XORpad, or is corrupt." % xorpad)
                if not genncchinfo:
                    print("  try using --gen-ncchinfo again or find the correct XORpad.")
                else:
                    ncchinfoadd(rom[0])
            print_v("  ExHeader SHA-256 hash check failed.")
            romf.close()
            if cleanup:
                docleanup(tid)
            continue

        print_v("- patching ExHeader")
        exh_list = list(exh)
        x = ord(exh_list[0xD])
        z = x | 2
        print_v("  offset 0xD of ExHeader:")
        print_v("  original: %s" % hex(x))
        print_v("  shifted:  %s" % hex(z))
        z = chr(z)
        exh_list[0xD:0xE] = z
        # there really has to be a better way to do this...
        # savesize = str(int(binascii.hexlify(exh[0x1C0:0x1C8][::-1]), 16) / 1024)
        exh = "".join(exh_list)
        savesize = exh[0x1C0:0x1C8]
        new_exh_hash = hashlib.sha256("".join(exh)).digest()

        if not decrypted:
            print_v("- re-encrypting ExHeader")
            xored = ""
            for byte_f, byte_x in zip(exh_list, xor):
                xored += chr(ord(byte_f) ^ ord(byte_x))
            exh = xored

        # Game Executable NCCH Header
        print_v("- reading NCCH header of Game Executable CXI")
        romf.seek(gamecxi_offset)
        ncch_header = list(romf.read(0x200))
        ncch_header[0x160:0x180] = list(new_exh_hash)
        ncch_header = "".join(ncch_header)

        # CIA
        with open(rom[2], "wb") as cia:
            print_v("- writing CIA header")
            chunkrecords  = "\x00" * 0xC  # 1st content: ID 0x00000000, Index 0x0000
            chunkrecords += struct.pack(">I", gamecxi_size)
            chunkrecords += "\x00" * 0x20  # sha256 hash to be filled in later
            if manualcfa_offset != 0:
                chunkrecords += binascii.unhexlify("000000010001000000000000")  # 2nd content: ID 0x00000001, Index 0x0001
                chunkrecords += struct.pack(">I", manualcfa_size)
                chunkrecords += "\x00" * 0x20  # sha256 hash to be filled in later
            if dlpchildcfa_offset != 0:
                chunkrecords += binascii.unhexlify("000000020002000000000000")  # 3nd content: ID 0x00000002, Index 0x0002
                chunkrecords += struct.pack(">I", dlpchildcfa_size)
                chunkrecords += "\x00" * 0x20  # sha256 hash to be filled in later

            cia.write(binascii.unhexlify("2020000000000000000A000050030000") + tmdsize
                      + struct.pack("<I", gamecxi_size + manualcfa_size + dlpchildcfa_size)
                      + ("\x00" * 4) + contentindex + ("\x00" * 0x201F)
                      + zlib.decompress(ciainfo.decode('base64'))
                      + chunkrecords + tmdpadding)

            chunkrecords = list(chunkrecords)  # to update hashes in it, then calculate the hash over the entire thing

            cia.seek(0x2C1C)
            cia.write(tid_bin)
            cia.seek(0x2F4C)
            cia.write(tid_bin)

            cia.seek(0x2F5A)
            cia.write(savesize)

            # Game Executable CXI NCCH Header + first-half ExHeader
            cia.seek(0, 2)
            gamecxi_hash = hashlib.sha256(ncch_header + exh)
            cia.write(ncch_header + exh)

            # Game Executable CXI second-half ExHeader + contents
            print_v("- writing Game Executable CXI")
            print_v("  offset: %s" % hex(gamecxi_offset))
            print_v("  size:   %s" % hex(gamecxi_size))
            romf.seek(gamecxi_offset + 0x200 + 0x400)
            left = gamecxi_size - 0x200 - 0x400
            tmpread = ""
            for __ in itertools.repeat(0, int(math.floor((gamecxi_size / readsize)) + 1)):
                toread = min(readsize, left)
                tmpread = romf.read(toread)
                gamecxi_hash.update(tmpread)
                cia.write(tmpread)
                left -= readsize
                if left <= 0:
                    break
            print_v("- Game Executable CXI SHA-256 hash:")
            print_v("  " + gamecxi_hash.hexdigest())
            cia.seek(0x38D4)
            cia.write(gamecxi_hash.digest())
            chunkrecords[0x10:0x30] = list(gamecxi_hash.digest())

            # Manual CFA
            if manualcfa_offset != 0:
                cia.seek(0, 2)
                print_v("- writing Manual CFA")
                manualcfa_hash = hashlib.sha256()
                print_v("  offset: %s" % hex(manualcfa_offset))
                print_v("  size:   %s" % hex(manualcfa_size))
                romf.seek(manualcfa_offset)
                left = manualcfa_size
                for __ in itertools.repeat(0, int(math.floor((manualcfa_size / readsize)) + 1)):
                    toread = min(readsize, left)
                    tmpread = romf.read(toread)
                    manualcfa_hash.update(tmpread)
                    cia.write(tmpread)
                    left -= readsize
                    if left <= 0:
                        break
                print_v("- Manual CFA SHA-256 hash:")
                print_v("  " + manualcfa_hash.hexdigest())
                cia.seek(0x3904)
                cia.write(manualcfa_hash.digest())
                chunkrecords[0x40:0x60] = list(manualcfa_hash.digest())


            # Download Play child container CFA
            if dlpchildcfa_offset != 0:
                cia.seek(0, 2)
                print_v("- writing Download Play child container CFA")
                dlpchildcfa_hash = hashlib.sha256()
                print_v("  offset: %s" % hex(dlpchildcfa_offset))
                print_v("  size:   %s" % hex(dlpchildcfa_size))
                romf.seek(dlpchildcfa_offset)
                left = dlpchildcfa_size
                for __ in itertools.repeat(0, int(math.floor((dlpchildcfa_size / readsize)) + 1)):
                    toread = min(readsize, left)
                    tmpread = romf.read(toread)
                    dlpchildcfa_hash.update(tmpread)
                    cia.write(tmpread)
                    left -= readsize
                    if left <= 0:
                        break
                print_v("- Download Play child container CFA SHA-256 hash:")
                print_v("  " + dlpchildcfa_hash.hexdigest())
                cia.seek(0x3934)
                cia.write(dlpchildcfa_hash.digest())
                chunkrecords[0x70:0x90] = list(dlpchildcfa_hash.digest())

            print_v("- updating hashes")
            chunkrecords_hash = hashlib.sha256("".join(chunkrecords))
            print_v("- Content chunk records SHA-256 hash:")
            print_v("  " + chunkrecords_hash.hexdigest())

            cia.seek(0x2FC7)
            cia.write(contentcount + chunkrecords_hash.digest())

            cia.seek(0x2FA4)
            inforecords_hash = hashlib.sha256("\x00\x00\x00" + contentcount + chunkrecords_hash.digest()
                                              + ("\x00"*0x8DC))
            print_v("- Content info records SHA-256 hash:")
            print_v("  " + inforecords_hash.hexdigest())
            cia.write(inforecords_hash.digest())

    if cleanup:
        docleanup(tid)

    processedroms += 1

if totalroms == 0:
    print(helptext % (version, ("current directory" if xorpad_directory == "" else "'%s'" % xorpad_directory),
                      ("current directory" if output_directory == "" else "'%s'" % output_directory),
                      ("the current directory" if xorpad_directory == "" else "'%s'" % xorpad_directory)))
    sys.exit(1)
else:
    if genncchinfo and len(ncchinfolist) != 0:
        print("- saving ncchinfo.bin")
        with open("ncchinfo.bin", "wb") as ncchinfo:
            ncchinfo.write("\xFF\xFF\xFF\xFF\x04\x00\x00\xF0")
            # this is bad, I know
            ncchinfo.write(binascii.unhexlify(format(len(ncchinfolist), 'x').rjust(8, '0'))[::-1])
            ncchinfo.write("\x00\x00\x00\x00")
            for i in ncchinfolist:
                ncchinfo.write(i)
        print("- use Decrypt9 on a 3DS system to generate the XORpads.")
        print("  place the file at the root or in a folder called \"Decrypt9\".")
        print("  view the Decrypt9 README and download releases at")
        print("  https://github.com/d0k3/Decrypt9WIP")
    print("* done converting!")
    print("  %i out of %i roms processed" % (processedroms, totalroms))
